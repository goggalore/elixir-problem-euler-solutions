defmodule PE.Fibonacci do
  @moduledoc """
  Documentation for `PE.Fibonacci`.
  """

  @doc """
  Each new term in the Fibonacci sequence is generated by adding the previous
  two terms. By starting with 1 and 2, the first 10 terms will be:

  1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...

  By considering the terms in the Fibonacci sequence whose values do not
  exceed four million, find the sum of the even-valued terms.

  """

  @spec get_term(non_neg_integer) :: non_neg_integer
  def get_term(0), do: 0
  def get_term(1), do: 1

  def get_term(n) do
    get_term(n - 1) + get_term(n - 2)
  end

  @spec sequence(integer) :: [non_neg_integer]
  def sequence(index) do
    if index < 0 do
      []
    else
      sequence(0, index, [])
    end
  end

  defp sequence(current_index, max_index, accum) do
    if current_index == max_index do
      [get_term(current_index) | accum]
    else
      sequence(current_index + 1, max_index, [get_term(current_index) | accum])
    end
  end

  @spec sequence_with_bound(integer) :: [non_neg_integer]
  def sequence_with_bound(bound) do
    index = 0
    sequence_with_bound(bound, index, [])
  end

  defp sequence_with_bound(bound, index, accum) do
    term = get_term(index)

    if term <= bound do
      sequence_with_bound(bound, index + 1, [term | accum])
    else
      accum
    end
  end

  @spec sum_sequence_with_bound(integer) :: number
  def sum_sequence_with_bound(bound) do
    sequence_with_bound(bound)
    |> Enum.sum()
  end
end

# note  E(n)=4*E(n-1)+E(n-2)
defmodule PE.Fibonacci.Even do
  @spec get_term(non_neg_integer) :: non_neg_integer
  def get_term(0), do: 0
  def get_term(1), do: 2

  def get_term(n) do
    4 * get_term(n - 1) + get_term(n - 2)
  end

  ## A lot of these functions are copypasta from previous module.
  ## Is there a way to generalize these without needing to pass a module as an arg?
  @spec sequence(integer) :: [non_neg_integer]
  def sequence(index) do
    if index < 0 do
      []
    else
      sequence(0, index, [])
    end
  end

  defp sequence(current_index, max_index, accum) do
    if current_index == max_index do
      [get_term(current_index) | accum]
    else
      sequence(current_index + 1, max_index, [get_term(current_index) | accum])
    end
  end

  @spec sequence_with_bound(integer) :: [non_neg_integer]
  def sequence_with_bound(bound) do
    sequence_with_bound(bound, 0, [])
  end

  defp sequence_with_bound(bound, index, accum) do
    term = get_term(index)

    if term <= bound do
      sequence_with_bound(bound, index + 1, [term | accum])
    else
      accum
    end
  end

  @spec sum_sequence_with_bound(integer) :: number
  def sum_sequence_with_bound(bound) do
    sequence_with_bound(bound)
    |> Enum.sum()
  end
end
